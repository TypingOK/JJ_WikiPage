const dummys = [
  {
    title: "JavaScript 기초 강의",
    content: `# React로 시작하는 프론트엔드 개발
React는 Facebook에서 개발한 JavaScript 라이브러리로, 사용자 인터페이스를 만들기 위한 도구입니다. 리액트는 가상 DOM을 사용하여 효율적인 UI 업데이트를 가능하게 하며, 컴포넌트 기반 아키텍처를 통해 코드의 재사용성과 유지보수성을 높입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다.
[50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
<br>

# 리액트 컴포넌트의 기본 구조
리액트 애플리케이션은 컴포넌트로 구성됩니다. [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
# JSX 문법
JSX는 JavaScript의 확장 문법으로, 리액트에서 UI를 표현하기 위해 사용됩니다. HTML과 유사하지만 JavaScript 코드로 감싸져 있습니다.
JSX를 사용하면 가독성이 높아지고, 컴포넌트의 구조를 직관적으로 파악할 수 있습니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.

# 상태 관리와 이벤트 처리
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
# 컴포넌트 간 통신

리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
`,
  },
  {
    title: "React 프로젝트 실습",
    content: `# React로 시작하는 프론트엔드 개발
React는 Facebook에서 개발한 JavaScript 라이브러리로, 사용자 인터페이스를 만들기 위한 도구입니다. [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론) 리액트는 가상 DOM을 사용하여 효율적인 UI 업데이트를 가능하게 하며, 컴포넌트 기반 아키텍처를 통해 코드의 재사용성과 유지보수성을 높입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
<br>

# 리액트 컴포넌트의 기본 구조
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
# JSX 문법
JSX는 JavaScript의 확장 문법으로, 리액트에서 UI를 표현하기 위해 사용됩니다. HTML과 유사하지만 JavaScript 코드로 감싸져 있습니다.
JSX를 사용하면 가독성이 높아지고, 컴포넌트의 구조를 직관적으로 파악할 수 있습니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.

# 상태 관리와 이벤트 처리
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
# 컴포넌트 간 통신

리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
`,
  },
  {
    title: "Node.js와 Express로 서버 구축하기",
    content: `# React로 시작하는 프론트엔드 개발
React는 Facebook에서 개발한 JavaScript 라이브러리로, 사용자 인터페이스를 만들기 위한 도구입니다. 리액트는 가상 DOM을 사용하여 효율적인 UI 업데이트를 가능하게 하며, 컴포넌트 기반 아키텍처를 통해 코드의 재사용성과 유지보수성을 높입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론) 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
<br>

# 리액트 컴포넌트의 기본 구조
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
# JSX 문법
JSX는 JavaScript의 확장 문법으로, 리액트에서 UI를 표현하기 위해 사용됩니다. HTML과 유사하지만 JavaScript 코드로 감싸져 있습니다.
JSX를 사용하면 가독성이 높아지고, 컴포넌트의 구조를 직관적으로 파악할 수 있습니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론) 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.
리액트 애플리케이션은 컴포넌트로 구성됩니다. 각 컴포넌트는 자체적으로 상태(state)를 가지며, UI를 렌더링하는 역할을 합니다. 예를 들어, 다음은 간단한 함수형 컴포넌트의 예시입니다.

# 상태 관리와 이벤트 처리
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
리액트에서 상태는 useState 훅을 사용하여 관리됩니다. 상태가 변경되면 리액트는 자동으로 컴포넌트를 다시 렌더링합니다.
# 컴포넌트 간 통신

리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론) 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
리액트에서 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. 자식 컴포넌트는 props를 통해 전달받은 데이터를 사용하여 렌더링합니다.
이와 같이 React를 사용하면 간단하게 모듈화된 컴포넌트를 구성하여 유연하고 효율적인 프론트엔드 개발을 할 수 있습니다.
`,
  },
  {
    title: "Git과 GitHub 협업 가이드",
    content: `오늘은 Next.js에 대해 배워보도록 하겠습니다.
        <br />
        **Next.js란**
        -
        Next.js는 React 프레임워크 중 하나입니다.
        <br />
        [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
        <br />
        위 링크를 눌러서 이동하여 확인 해보도록 합시다.
        `,
  },
  {
    title: "Python 데이터 분석 강좌",
    content: `오늘은 Next.js에 대해 배워보도록 하겠습니다.
        <br />
        **Next.js란**
        -
        Next.js는 React 프레임워크 중 하나입니다.
        <br />
        [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
        <br />
        위 링크를 눌러서 이동하여 확인 해보도록 합시다.
        `,
  },
  {
    title: "웹 개발 기초",
    content: `오늘은 Next.js에 대해 배워보도록 하겠습니다.
        <br />
        **Next.js란**
        -
        Next.js는 React 프레임워크 중 하나입니다.
        <br />
        [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
        <br />
        위 링크를 눌러서 이동하여 확인 해보도록 합시다.
        `,
  },
  {
    title: "Vue.js 실전 프로젝트",
    content: `오늘은 Next.js에 대해 배워보도록 하겠습니다.
        <br />
        **Next.js란**
        -
        Next.js는 React 프레임워크 중 하나입니다.
        <br />
        [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
        <br />
        위 링크를 눌러서 이동하여 확인 해보도록 합시다.
        `,
  },
  {
    title: "Django로 블로그 만들기",
    content: `오늘은 Next.js에 대해 배워보도록 하겠습니다.
        <br />
        **Next.js란**
        -
        Next.js는 React 프레임워크 중 하나입니다.
        <br />
        [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
        <br />
        위 링크를 눌러서 이동하여 확인 해보도록 합시다.
        `,
  },
  {
    title: "Git 고급 활용",
    content: `오늘은 Next.js에 대해 배워보도록 하겠습니다.
        <br />
        **Next.js란**
        -
        Next.js는 React 프레임워크 중 하나입니다.
        <br />
        [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
        <br />
        위 링크를 눌러서 이동하여 확인 해보도록 합시다.
        `,
  },
  {
    title: "머신러닝 기초 이론",
    content: `오늘은 Next.js에 대해 배워보도록 하겠습니다.
        <br />
        **Next.js란**
        -
        Next.js는 React 프레임워크 중 하나입니다.
        <br />
        [50번째 강의 머신러닝 기초 이론](http://localhost:3000/50번째%20강의%20머신러닝%20기초%20이론)
        <br />
        위 링크를 눌러서 이동하여 확인 해보도록 합시다.
        `,
  },
];

const dummyPosts = Array.from({ length: 62 }, (_, index) => ({
  id: index + 1,
  title: index + 1 + "번째 강의 " + dummys[index % 10].title,
  content: dummys[index % 10].content,
}));

export const getDummyPost = () => {
  return dummyPosts;
};
